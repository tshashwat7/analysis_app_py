<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>üìà NSE Stock Analyzer (AG Grid)</title>
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-community/styles/ag-grid.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-community/styles/ag-theme-alpine.css" />
    
    <script src="https://cdn.jsdelivr.net/npm/ag-grid-community/dist/ag-grid-community.min.js"></script>

    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 20px; background: #f4f7f6; }
        h1 { text-align: center; color: #333; margin-bottom: 20px; }
        .controls { text-align:center; margin-bottom:12px; }
        input, button, select { padding:8px 10px; margin:4px; font-size:14px; border: 1px solid #ccc; border-radius: 4px; }
        button { background: #007bff; color: white; cursor: pointer; }
        button:disabled { background: #aaa; }
        
        #myGrid { 
            height: 75vh; 
            width: 100%; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        }
        
        .progress { width:100%; max-width:1200px; margin:8px auto; background:#eee; height:12px; border-radius:8px; overflow:hidden; }
        .progress-bar { height:100%; width:0%; background:linear-gradient(90deg,#3bbf7f,#2aa06b); transition:width .25s; }
        .status { text-align:center; margin-top:6px; font-weight:600; }

        /* Cell Styling */
        .buy-cell { color: #16a34a; font-weight: bold; }
        .hold-cell { color: #d97706; font-weight: bold; }
        .sell-cell { color: #dc2626; font-weight: bold; }
        .ticker-link { color: #2563eb; text-decoration: none; font-weight: 600; }
        .ticker-link:hover { text-decoration: underline; }
        
        /* Score Coloring */
        .score-buy { color: #16a34a; font-weight: bold; }
        .score-hold { color: #d97706; font-weight: bold; }
        .score-sell { color: #dc2626; font-weight: bold; }
    </style>
</head>

<body>
    <h1>üìà NSE Stock Analyzer</h1>

    <div class="controls">
        <form action="/analyze" method="get" style="display:inline-block;">
            <input name="symbol" placeholder="Enter ticker (e.g. RELIANCE.NS)" required>
            <button type="submit">Analyze</button>
        </form>
        <br>

        <select id="indexSelect">
            <option value="nifty50">Nifty 50</option>
            <option value="nifty100">Nifty 100</option>
            <option value="niftynext50">Nifty Next 50</option>
            <option value="nifty500">Nifty 500</option>
            <option value="midcap150">Midcap 150</option>
            <option value="smallcap100">Smallcap 100</option>
            <option value="NSEStock">All Stocks</option>
        </select>
        <button id="loadBtn" onclick="loadIndex()">üîÑ Load Index</button>

        <br>
        <button id="startBtn" onclick="startAutoAnalyze()" disabled>Start Auto Analysis</button>
        <button id="stopBtn" onclick="stopAutoAnalyze()" disabled>Stop</button>
        <button onclick="gridApi.exportDataAsCsv()">Export CSV</button>
    </div>

    <div class="progress"><div id="progressBar" class="progress-bar"></div></div>
    <div id="status" class="status">Idle</div>

    <div id="myGrid" class="ag-theme-alpine"></div>
    
<script>
    let gridApi; 
    let isAutoAnalysisActive = false; // Master switch for Auto-Analysis
    let isPageAnalyzing = false;      // Lock to prevent self-triggering loops
    let lastAnalyzedPage = -1;        // Track which page we finished

    // --- 1. Global Helpers ---
    function setStatus(t){ 
        const el = document.getElementById("status");
        if(el) el.innerText = t; 
    }
    function setProgress(p){ 
        const el = document.getElementById("progressBar");
        if(el) el.style.width = p + "%"; 
    }
    
    // --- 2. Column Definitions ---
const columnDefs = [
        // 1. Ticker (Pinned Left)
        { 
            field: "symbol", 
            headerName: "Ticker", 
            pinned: 'left', 
            width: 110,
            cellRenderer: p => `<a href="/analyze?symbol=${p.value}" class="ticker-link" target="_blank">${p.value}</a>` 
        },
        { field: "name", headerName: "Company Name", width: 160 },

        // 2. NEW: Alignment (Confluence) Column
        // Shows 3 dots for Intra/Short/Long scores. 
        // Green dot = Score > 7. Grey dot = Score < 7.
        {
            headerName: "Align",
            width: 90,
            cellRenderer: params => {
                if (!params.data) return '';
                
                // Logic: Threshold is 7.0 for a "Good" score
                const i = (params.data.intra_score || 0) >= 7;
                const s = (params.data.short_score || 0) >= 7;
                const l = (params.data.long_score || 0)  >= 7;
                
                const dot = (active) => `<span style="font-size:16px; margin:0 2px; color:${active ? '#22c55e' : '#e5e7eb'};">‚óè</span>`;
                
                // Tooltip shows the exact numbers on hover
                const tip = `Intra: ${params.data.intra_score || '-'} | Short: ${params.data.short_score || '-'} | Long: ${params.data.long_score || '-'}`;
                
                return `<div title="${tip}" style="cursor:help; letter-spacing: -2px;">${dot(i)}${dot(s)}${dot(l)}</div>`;
            }
        },

        // 3. Overall Score
        { 
            field: "score", headerName: "Score", width: 90, sortable: true, filter: 'agNumberColumnFilter',
            cellClass: p => p.value >= 70 ? 'score-buy' : p.value < 40 ? 'score-sell' : 'score-hold'
        },

        // 4. Recommendation (Buy/Sell/Hold)
        { 
            field: "recommendation", headerName: "Rec.", width: 100, sortable: true, filter: true,
            cellClass: p => p.value === 'BUY' ? 'buy-cell' : p.value === 'SELL' ? 'sell-cell' : 'hold-cell' 
        },

        // 5. NEW: R:R Ratio (Actionable)
        { 
            field: "rr_ratio", headerName: "R:R", width: 80, sortable: true, filter: 'agNumberColumnFilter',
            cellClass: p => p.value >= 2.0 ? 'buy-cell' : 'hold-cell',
            valueFormatter: p => p.value ? p.value + "R" : "-"
        },

        // 6. NEW: Risk % (Distance to Stop Loss)
        { 
            field: "sl_dist", headerName: "Risk %", width: 90, 
            cellStyle: { 'color': '#dc2626', 'font-weight': '500' }
        },

        // 7. Timing Signal (Styled with Badges)
        { 
            field: "bull_signal", headerName: "Signal", width: 150, sortable: true, filter: true,
            cellRenderer: p => {
                const val = p.value || "";
                if (val.includes("SQUEEZE")) return `<span style="background:#d1fae5; color:#065f46; padding:2px 6px; border-radius:4px; font-size:12px;">üöÄ ${val}</span>`;
                if (val.includes("TREND")) return `<span style="background:#dbeafe; color:#1e40af; padding:2px 6px; border-radius:4px; font-size:12px;">üìà ${val}</span>`;
                if (val.includes("DIP")) return `<span style="background:#fef3c7; color:#92400e; padding:2px 6px; border-radius:4px; font-size:12px;">üìâ ${val}</span>`;
                return val;
            }
        },

        // 8. Confidence Bar
        { 
            field: "confidence", headerName: "Conf %", width: 90, sortable: true, filter: 'agNumberColumnFilter',
            cellRenderer: params => {
                const val = params.value || 0;
                const color = val > 70 ? '#22c55e' : val > 40 ? '#facc15' : '#ef4444';
                return `<div style="width: 100%; background: #eee; height: 6px; border-radius: 3px; margin-top: 15px;">
                        <div style="width: ${val}%; background: ${color}; height: 100%; border-radius: 3px;"></div></div>`;
            }
        },

        // 9. Company Name

        // 10. Horizon Scores (Hidden by default, but available for the 'Align' column logic)
        { field: "intra_score", hide: true },
        { field: "short_score", hide: true },
        { field: "long_score", hide: true },
        { field: "multi_score", hide: true },

        // 11. Corporate Actions
        { field: "corp_action", headerName: "Upcoming Event", width: 180, sortable: true, filter: true },
    ];

    // --- 3. Grid Options ---
    const gridOptions = {
        columnDefs: columnDefs,
        theme: "legacy",
        rowData: [],
        rowModelType: 'clientSide', 
        pagination: true,
        paginationPageSize: 50,
        paginationPageSizeSelector: [20, 50, 100, 500],
        defaultColDef: { resizable: true, sortable: true, filter: true },
        getRowId: params => params.data.symbol,
        defaultColDef: { 
            resizable: true, 
            sortable: true, 
            filter: true,
            flex: 1,        // <--- Makes columns auto-size to fill width
            minWidth: 80,   // <--- Prevents columns from crushing too small
        },
        // --- CRITICAL: Trigger analysis when page changes ---
        onPaginationChanged: onPageChange
    };

    // --- 4. Initialize ---
    document.addEventListener('DOMContentLoaded', () => {
        const gridDiv = document.querySelector('#myGrid');
        gridApi = agGrid.createGrid(gridDiv, gridOptions);
    });

    // --- 5. Pagination Event Handler (FIXED) ---
    function onPageChange() {
        if (isAutoAnalysisActive) {
            // Only trigger if we are NOT already running an analysis
            // This prevents the "0/40... 0/30" loop
            if (!isPageAnalyzing) {
                const currentPage = gridApi.paginationGetCurrentPage();
                // Optional: Only re-analyze if we moved to a NEW page
                if (currentPage !== lastAnalyzedPage) {
                    analyzeCurrentView();
                }
            }
        }
    }

// --- 6. Concurrent Batch Analysis with Auto-Nav ---

// Helper: Pause execution
const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

async function analyzeCurrentView() {
    if (!gridApi) return;
    
    // LOCK: Prevent re-entry
    if (isPageAnalyzing) return;
    isPageAnalyzing = true;

    const index_name = document.getElementById("indexSelect").value;
    
    // 1. Identify rows
    const pageSize = gridApi.paginationGetPageSize();
    const currentPage = gridApi.paginationGetCurrentPage();
    const totalPages = gridApi.paginationGetTotalPages();
    const startRow = currentPage * pageSize;
    const endRow = startRow + pageSize;

    const symbolsToAnalyze = [];
    
    gridApi.forEachNodeAfterFilterAndSort((node) => {
        if (node.rowIndex >= startRow && node.rowIndex < endRow) {
            // Optimization: Only analyze if score is missing
            if (node.data.score === null || node.data.score === undefined) {
                symbolsToAnalyze.push(node.data.symbol);
            }
        }
    });

    // 2. Handle Empty Page / Already Analyzed
    if (symbolsToAnalyze.length === 0) {
        setStatus(`Page ${currentPage + 1} is up to date.`);
        setProgress(100);
        lastAnalyzedPage = currentPage;
        handleAutoNavigation(currentPage, totalPages); // Move next if Auto-On
        isPageAnalyzing = false; 
        return;
    }

    // 3. BATCHING LOGIC (Your UX Optimization)
    const BATCH_SIZE = 5; 
    const batches = [];
    for (let i = 0; i < symbolsToAnalyze.length; i += BATCH_SIZE) {
        batches.push(symbolsToAnalyze.slice(i, i + BATCH_SIZE));
    }

    let completedCount = 0;
    const total = symbolsToAnalyze.length;
    setStatus(`0/${total} Analyzed on Page ${currentPage + 1}...`);
    setProgress(5);

    // 4. Process Batches Concurrently
    // We map each batch to a fetch Promise
    const tasks = batches.map(async (batch) => {
        const MAX_RETRIES = 3;
        
        for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
            try {
                const resp = await fetch("/quick_scores", {
                    method: "POST",
                    headers: {"Content-Type":"application/json"},
                    body: JSON.stringify({symbols: batch, index_name: index_name})
                });
                
                if(!resp.ok) throw new Error(`HTTP ${resp.status}`);
                
                const map = await resp.json();
                
                // Update Grid INCREMENTALLY
                const updates = [];
                for(const s of batch){
                    if(map[s]){
                        const node = gridApi.getRowNode(s);
                        if(node && node.data){
                            updates.push({ 
                                ...node.data, 
                                ...map[s],
                                name: node.data.name, 
                                corp_action: node.data.corp_action
                            }); 
                        }
                    }
                }
                if (updates.length > 0) {
                    gridApi.applyTransaction({ update: updates });
                }

                // Update Progress
                completedCount += batch.length;
                const percent = Math.floor((completedCount / total) * 100);
                setStatus(`${completedCount}/${total} Analyzed...`);
                setProgress(percent);
                
                break; // Success! Exit retry loop

            } catch(err) {
                console.error(`Batch failed (Attempt ${attempt}):`, err);
                if (attempt < MAX_RETRIES) {
                    await wait(2000); // Retry delay
                }
            }
        }
    });

    // 5. Wait for ALL batches to finish
    await Promise.all(tasks);

    setStatus(`Page ${currentPage + 1} Complete.`);
    setProgress(100);
    lastAnalyzedPage = currentPage;
    
    // 6. Navigation Decision (Auto-Advance)
    handleAutoNavigation(currentPage, totalPages);
    isPageAnalyzing = false; // Unlock
}

// --- AUTO-NAV HELPER (Same as before) ---
async function handleAutoNavigation(currentPage, totalPages) {
    if (!isAutoAnalysisActive) return;

    if (currentPage < totalPages - 1) {
        await wait(1000); 
        lastAnalyzedPage = currentPage; 
        gridApi.paginationGoToNextPage(); 
    } else {
        setStatus("Analysis Complete: All pages scanned.");
        stopAutoAnalyze();
        alert("Full Market Scan Complete! üöÄ");
    }
}

// --- 7. Button Handlers (Updated) ---

function startAutoAnalyze(){
    if (isAutoAnalysisActive) return; // Prevent double clicks
    
    isAutoAnalysisActive = true;
    document.getElementById("startBtn").disabled = true;
    document.getElementById("stopBtn").disabled = false;
    document.getElementById("loadBtn").disabled = true; // Lock load during run
    document.getElementById("startBtn").innerText = "Running...";
    document.getElementById("startBtn").style.background = "#e2e8f0";
    document.getElementById("startBtn").style.color = "#333";
    
    // Reset page tracking to force analysis of current view
    lastAnalyzedPage = -1; 
    analyzeCurrentView();
}

function stopAutoAnalyze(){ 
    isAutoAnalysisActive = false; 
    
    // Reset Buttons
    const startBtn = document.getElementById("startBtn");
    startBtn.disabled = false;
    startBtn.innerText = "Start Auto Analysis";
    startBtn.style.background = "#007bff"; // Restore blue color
    startBtn.style.color = "white";

    document.getElementById("stopBtn").disabled = true;
    document.getElementById("loadBtn").disabled = false; // Re-enable load
    
    setStatus("Auto-Analysis Stopped / Finished.");
    setProgress(0);
}

    // --- 8. Load Index ---
    async function loadIndex(){
        const idx = document.getElementById("indexSelect").value;
        setStatus(`Loading ${idx.toUpperCase()} tickers...`);
        setProgress(0);
        document.getElementById("loadBtn").disabled = true;
        
        if(isAutoAnalysisActive) stopAutoAnalyze();

        try {
            const res = await fetch(`/load_index/${idx}`);
            const j = await res.json();
            
            if(j.error) {
                setStatus(`Error: ${j.error}`);
                document.getElementById("loadBtn").disabled = false;
                return;
            }

            const rowData = j.tickers.map(t => ({
                symbol: t,
                name: j.pairs ? j.pairs[t] : t,
                score: null, 
                recommendation: "--",
                bull_signal: "--",
                corp_action: ""
            }));
            
            gridApi.setGridOption('rowData', rowData);
            
            // Reset state
            lastAnalyzedPage = -1;
            setProgress(100);
            setStatus(`Loaded ${rowData.length} tickers. Ready to analyze.`);
            document.getElementById("startBtn").disabled = false;
            
            populateCorporateActions(j.tickers);

        } catch(err){
            console.error(err);
            setStatus("Failed to load index");
        }
        document.getElementById("loadBtn").disabled = false;
    }
    
    // --- 9. Corporate Actions (Fixed: Chunks entire list) ---
async function populateCorporateActions(tickers) {
    if (!tickers || tickers.length === 0) return;
    
    // Process in chunks of 50 to avoid payload limits
    const CHUNK_SIZE = 50;
    
    for (let i = 0; i < tickers.length; i += CHUNK_SIZE) {
        const chunk = tickers.slice(i, i + CHUNK_SIZE);
        
        try {
            // Run in background (no await) to let UI stay responsive
            fetch('/corporate_action_summary', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ tickers: chunk })
            })
            .then(res => res.json())
            .then(summary => {
                if (!summary) return;
                const rowsToUpdate = [];
                for (const [sym, info] of Object.entries(summary)) {
                    if (info && info !== "-") {
                        const node = gridApi.getRowNode(sym);
                        if(node && node.data){
                            rowsToUpdate.push({
                                ...node.data,
                                corp_action: info 
                            });
                        }
                    }
                }
                if(rowsToUpdate.length > 0) {
                    gridApi.applyTransaction({ update: rowsToUpdate });
                }
            });
            
            // Small delay between chunks to be nice to the server
            await new Promise(r => setTimeout(r, 200)); 

        } catch (e) { console.error("Corp Action Error:", e); }
    }
}
</script>
</body>
</html>